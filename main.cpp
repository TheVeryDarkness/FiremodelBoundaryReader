/// @file main.cpp
/// @author Boyi Huang
/// @mainpage Written by Boyi Huang, who was a student in Tongji University when
/// he wrote this. C++17 is required for filesystem operation. GLAD and GLFW3 is
/// required for boundary patch display. For reading .bf files generated by fds.
/// See Source/dump.f90 in fds reposity for more information, especailly codes
/// that are writing data to LU_BNDF(NF,NM). See also section Boundary Files in
/// FDS_User_Guide.pdf. As for opengl, most of the codes about opengl are
/// adapted from https://github.com/JoeyDeVries/LearnOpenGL.
#include "analysis.hpp"
#include "graphics.hpp"
#include "io.hpp"
#include "types.hpp"
#include <array>
#include <cassert>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <optional>
#include <sstream>
#include <string>
#include <valarray>
#include <vector>

using std::cin;
using std::conditional_t;
using std::cout;
using std::endl;
using std::getline;
using std::hex;
using std::ifstream;
using std::ios;
using std::optional;
using std::setprecision;
using std::string;
using std::filesystem::current_path;
using std::filesystem::directory_entry;
using std::filesystem::directory_iterator;
using std::filesystem::is_regular_file;
using std::filesystem::path;

static inline void search_frame_by_time(const vector<frame> &frames) {
  using std::cin;
  using std::cout;
  constexpr auto help = R"(
Choose search mode.
> - Earliest frame later than given time.
< - Latest frame earlier than given time.
+ - Earliest frame not earlier than given time.
- - Latest frame not later than given time.
d - Discard.
)";
  while (true) {
    cout << help;

    char op4 = 'd';
    cin >> op4;
    const auto time_search =
        [&frames = frames](bool (*pred)(float, float, float), bool right) {
          float t = NAN;
          cin >> t;
          for (size_t i = 1; i < frames.size(); ++i)
            if (pred(frames[i - 1].time, t, frames[i].time)) {
              cout << "Frame " << i << " at " << frames[right ? i : i - 1].time
                   << "s." << endl;
              return;
            }
          cout << "Not found." << endl;
        };
    switch (op4) {
    case '>': {
      time_search(
          [](float prev, float t, float cur) { return prev <= t && t < cur; },
          true);
    } break;
    case '+': {
      time_search(
          [](float prev, float t, float cur) { return prev < t && t <= cur; },
          true);
    } break;
    case '<': {
      time_search(
          [](float cur, float t, float next) { return cur <= t && t < next; },
          false);
    } break;
    case '-': {
      time_search(
          [](float cur, float t, float next) { return cur < t && t <= next; },
          false);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_frame(const vector<frame> &frames) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
t - Time.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << frames.size()
           << " frames in total." << endl;
      u32 f = 0;
      cin >> f;
      if (f >= frames.size()) {
        cout << "Not a valid frame." << endl;
        break;
      }
      cout << "Frame " << f << " is at " << frames[f].time << "s." << endl;
    } break;
    case 't': {
      search_frame_by_time(frames);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_patch(const vector<patch_info> &patches) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << patches.size()
           << " patches in total." << endl;
      u32 p = 0;
      cin >> p;
      if (p >= patches.size()) {
        cout << "Not a valid patch." << endl;
        break;
      }
      cout << "Patch " << p << ": " << patches[p] << endl;
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

/*
 * @retval File stream that reads the corresponding file.
 */
static inline optional<ifstream> select_file() {
  constexpr auto help = R"(
Choose what to do next.
h - Show this help list.
d - Show all sub-directories in current directory and change current working directory.
s - Select a file to read.
r - Read file with specified name.
c - Change current working directory.
p - Change current directory to parent directory if there is one.
q - quit
)";
  cout << help;
  while (true) {
    auto cp = current_path();
    auto di = directory_iterator(cp);

    cout << endl << cp.string() << "> ";
    char opt = 'q';
    cin >> opt;
    switch (opt) {
    case 'd': {
      size_t i = 0;
      vector<directory_entry> entries;
      for (const auto &entry : di)
        if (entry.is_directory()) {
          cout << i << " - " << entry.path().generic_string() << endl;
          entries.push_back(entry);
          ++i;
        }
      if (entries.empty()) {
        cout << "No sub-directory found." << endl;
        break;
      }
      cout << "Directory index(Invalid index to discard): ";
      cin >> i;
      if (i < entries.size())
        current_path(entries[i]);
    } break;
    case 's': {
      vector<path> files;
      for (const auto &entry : di) {
        const auto &path = entry.path();
        if (path.extension() == ".bf") {
          files.push_back(path);
        }
      }
      cout << "There are " << files.size()
           << " .bf files in total in current directory." << endl;
      if (files.empty()) {
        cout << ".bf files not found in current directory." << endl;
        continue;
      }
      size_t i = 0;
      for (const auto &file : files) {
        cout << i << " - " << file.string() << endl;
        ++i;
      }
      cout << "File index: ";
      cin >> i;
      if (i >= files.size()) {
        cout << "Not a valid file index." << endl;
        continue;
      }
      auto fin = ifstream(files[i], ios::binary);
      if (fin.is_open())
        return fin;
      cout << "Failed to open." << endl;
      continue;
    } break;
    case 'c': {
      cout << "Directory: ";
      string s;
      getline(cin, s);
      if (s.empty())
        getline(cin, s);
      path p = s;
      if (is_directory(p))
        current_path(p);
      else
        cout << "Not a directory." << endl;
    } break;
    case 'r': {
      cout << "File: ";
      string s;
      getline(cin, s);
      if (s.empty())
        getline(cin, s);
      path p = s;
      if (is_regular_file(p))
        current_path(p);
      else {
        cout << "Not a file." << endl;
        continue;
      }

      auto fin = ifstream(p, ios::binary);
      if (fin.is_open())
        return fin;
      cout << "Failed to open." << endl;
      continue;
    } break;
    case 'p': {
      current_path(current_path().parent_path());
    } break;
    case 'q': {
      return {};
    }
    default:
      cout << "Command not found." << endl;
    case 'h': {
      cout << help;
    } break;
    }
  }
}

static inline void analyze_patch(const vector<patch_info> &patches,
                                 const vector<frame> &frames, u32 i_patch) {
  const auto &patch = patches[i_patch];
  vector<float> data;
  vector<u32> sizes;
  while (true) {
    cout << R"(
Commands:
m - Show current dimensions.
p - Print current result to console.
P - Set default flaot-point number precision.
w - Input in console to overlap current result.
f - Flatten current result to specified dimension.
s - Take patch data in a frame as current result.
S - Sample.
B - Save current result as binary to file.
C - Save current result as CSV file.
a - Calculate average on specified dimension of current result.
A - Copy data in all frames of this patch as current result.
d - Discard.
)";
    char opt = 'd';
    cin >> opt;
    switch (opt) {
    case 'd':
      return;
    case 'w': {
      cout << "Size(0 to stop): ";
      u32 sz = 0;
      sizes.clear();
      do {
        sz = 0;
        cin >> sz;
        if (sz == 0)
          break;
        sizes.push_back(sz);
      } while (true);

      u32 data_size = array_stride(sizes, 0);

      float e = 0.f;
      data.clear();
      data.reserve(data_size);
      while (data.size() < data_size) {
        cin >> e;
        data.push_back(e);
      }
    } break;
    case 'm': {
      if (sizes.empty())
        break;
      auto begin = sizes.cbegin(), end = sizes.cend();
      cout << *begin;
      ++begin;
      for (; begin != end; ++begin)
        cout << '*' << *begin;
    } break;
    case 'p': {
      u16 precision = input_precision();
      cout << setprecision(precision);

      auto [m, n] = get_matrix_size(sizes);
      if (n != 0)
        print_patch(data, m, n);
    } break;
    case 'P': {
      u16 precision = input_precision();
      set_default_precision(precision);
    } break;
    case 'l':
      reduce_dimension(sizes, 1);
      if (sizes.size() > 1)
        cout << "Linearization failed. Current dimension is " << sizes.size()
             << "." << endl;
      break;
    case 's': {
      cout << "Frame index: ";
      auto f = frames.size();
      cin >> f;
      if (f >= frames.size()) {
        cout << "Frame index invalid." << endl;
        break;
      }
      data = frames[f].data[i_patch].data;
      sizes = {patch.I(), patch.J(), patch.K()};
    } break;
    case 'S': {
      size_t dimension = -1;
      cin >> dimension;
      if (dimension >= sizes.size() || sizes.size() == 1) {
        cout << "Dimension invalid." << endl;
        break;
      }
      const auto sz = sizes[dimension];
      cout << "Size of this dimension: " << sz << endl;
      vector<u32> pos;
      while (true) {
        u32 i = -1;
        cin >> i;
        if (i >= sz)
          break;
        pos.push_back(i);
      }

      data = sample(data, sizes, dimension, pos);
      sizes[dimension] = (u32)pos.size();

    } break;
    case 'B': {
      cout << "File name: ";
      string path;
      getline(cin, path);
      ofstream fout(path, ios::binary);
      if (!fout) {
        cout << "Failed to open file." << endl;
        break;
      }
      save_patch_as_binary(data, sizes, fout);
    } break;
    case 'C': {
      cout << "File name: ";
      string path;
      getline(cin, path);
      ofstream fout(path);
      if (!fout) {
        cout << "Failed to open file." << endl;
        break;
      }

      u16 precision = input_precision();
      fout << setprecision(precision);

      auto [m, n] = get_matrix_size(sizes);
      save_patch_as_csv_text(data, m, n, fout);
    } break;
    case 'f': {
      size_t d = 2;
      cin >> d;
      reduce_dimension(sizes, d);
      if (sizes.size() > d)
        cout << "Flattening failed. Current dimension is " << sizes.size()
             << "." << endl;
    } break;
    case 'a': {
      // Consider [l][m][n]
      size_t dimension = -1;
      cin >> dimension;
      if (dimension >= sizes.size() || sizes.size() == 1) {
        cout << "Dimension invalid." << endl;
        break;
      }
      data = average(data, sizes, dimension);
      sizes.erase(sizes.cbegin() + dimension);

    } break;
    case 'A': {
      sizes = {(u32)frames.size(), patch.I(), patch.J(), patch.K()};
      data.clear();
      data.reserve(array_stride(sizes, 0));
      for (const auto &frame : frames) {
        const auto &patch = frame.data[i_patch];
        data.insert(data.cend(), patch.data.cbegin(), patch.data.cend());
      }
    } break;
    default:
      break;
    }
  }
}

static inline void select_patch(const vector<patch_info> &patches,
                                const vector<frame> &frames) {
  u32 p = 0;
  cout << "Select a patch to analyze. Input an invalid index to discard."
       << endl;
#if GRAPHICS_ENABLED
  if (current < patches.size())
    cout << "Current patch selected in graphics mode is: " << current << "."
         << endl;
#endif // GRAPHICS_ENABLED

  cout << "Patch index: ";
  cin >> p;
  if (p >= patches.size()) {
    return;
  }

  analyze_patch(patches, frames, p);
}

/// @retval Whether to quit.
/// @param label Boundary quantity label.
/// @param bar_label Boundary quantity label shown on the bar.
/// @param units Display units.
/// @param patches Information of patches stored in the .bf file.
/// @param frames Information and boundary quantity data of frames stored in the
/// .bf file.
template <bool patches_read, bool frames_read>
static inline bool process_file(
    const array<char, 30 + 1> &label, const array<char, 30 + 1> &bar_label,
    const array<char, 30 + 1> &units,
    const conditional_t<patches_read, vector<patch_info>, tuple<>> &patches,
    const conditional_t<frames_read, vector<frame>, tuple<>> &frames) {
  auto help = []() {
    cout <<
        R"(
Commands: 
q - Quit.
h - Show this help.
u - Unload file.
b - Show boundary quantity basic information.)";

    if constexpr (frames_read)
      cout << R"(
f - Show frames.
F - Search for frame.)";

    if constexpr (patches_read)
      cout << R"(
p - Show patches.
P - Search for Patch.)"
#if GRAPHICS_ENABLED
              R"(
g - Visualize patches geometry.)"
#endif // GRAPHICS_ENABLED
          ;

    if constexpr (patches_read && frames_read)
      cout << R"(
a - Analyze patch data.)";

    cout << endl;
  };
  help();
  while (true) {
    cout << "Please input your command here: ";
    char op1 = 'q';
    cin >> op1;
    switch (op1) {
    case 'q':
      return true;
    case 'u':
      return false;
    case 'b': {
      print_header(cout, label, bar_label, units);
    } break;
    case 'a': {
      if constexpr (patches_read && frames_read)
        select_patch(patches, frames);
      else
        goto CMDNF;
    } break;
    case 'f': {
      if constexpr (frames_read)
        print_frames(cout, frames);
      else
        goto CMDNF;
    } break;
#if GRAPHICS_ENABLED
    case 'g': {
      if constexpr (patches_read)
        visualize_patch(patches);
      else
        goto CMDNF;
    } break;
#endif // GRAPHICS_ENABLED
    case 'p': {
      if constexpr (patches_read)
        print_patches(cout, patches);
      else
        goto CMDNF;
    } break;
    case 'F': {
      if constexpr (frames_read)
        search_frame(frames);
      else
        goto CMDNF;
    } break;
    case 'P': {
      if constexpr (patches_read)
        search_patch(patches);
      else
        goto CMDNF;
    } break;
    case 'h':
      help();
      break;
    default:
    CMDNF:
      cout << "Command not found." << endl;
      help();
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  while (true) {
    try {
      cerr << hex;

      auto in = select_file();
      if (!in.has_value())
        return 1;
      auto &fin = in.value();
      fin.peek();
      if (!fin) {
        cout << "Failed to open the file." << endl;
      }

      cout << R"(
h - Header only.
p - Header and patches.
f - Header, patches and all frames.
d - Discard.
)";
      char c = 'd';
      cin >> c;
      switch (c) {
      case 'h': {
        cout << "Reading started." << endl;
        auto [label, bar_label, units] = read_file_header(fin);
        cout << "Reading finished." << endl;

        bool quitting =
            process_file<false, false>(label, bar_label, units, {}, {});
        if (quitting)
          return 0;
      } break;
      case 'p': {
        cout << "Reading started." << endl;
        auto [label, bar_label, units, patches] =
            read_file_header_and_patches(fin);
        cout << "Reading finished." << endl;

        bool quitting =
            process_file<true, false>(label, bar_label, units, patches, {});
        if (quitting)
          return 0;
      } break;
      case 'f': {
        cout << "Reading started." << endl;
        auto [label, bar_label, units, patches, frames] = read_file(fin);
        cout << "Reading finished." << endl;

        bool quitting =
            process_file<true, true>(label, bar_label, units, patches, frames);
        if (quitting)
          return 0;
      } break;
      default:
        break;
      }

    } catch (const exception &e) {
      cerr << "Exception caught: " << e.what() << endl;
    }
  }

  return 0;
}