// Written by Boyi Huang,
// who was a student in Tongji University when he wrote this.
// C++17 is required for filesystem operation.
// For reading .bf files generated by fds.
// See Source/dump.f90 in fds reposity for more information,
// especailly codes that are writing data to LU_BNDF(NF,NM).
// See also section Boundary Files in FDS_User_Guide.pdf.
#include <array>
#include <cassert>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <optional>
#include <vector>

using namespace std;
template <size_t sz> static inline void read(istream &in, array<char, sz> &s) {
  assert(in);
  static_assert(sz > 0);
  in.get(s.data(), sz);
}

// Actually I'm not sure about their meanings.
constexpr const char string_separator[] = "\x1E\x00\x00\x00";
constexpr const char integer_separator[] = "\x04\x00\x00\x00";
constexpr const char line_separator[] = "\x24\x00\x00\x00";

template <size_t sz>
static inline void write_line(ostream &out, array<char, sz> &s) {
  out.write(s.data(), sz) << endl;
}

template <typename Ty>
static inline ostream &write_number(ostream &out, const Ty &val,
                                    const char *sep = " ") {
  return out << setw(numeric_limits<Ty>::digits10 + 1) << val << sep;
}

static inline ostream &write_bytes(ostream &out, char c,
                                   const char *sep = " ") {
  return out << setw(sizeof(c)) << (unsigned)(unsigned char)(c) << sep;
}

template <size_t sz>
static inline void check(istream &in, const char (&s)[sz]) {
  assert(in);
  static_assert(sz > 0);
  char buf[sz];
  buf[sz - 1] = 0;
  in.read(buf, sz - 1);
  if (strcmp(buf, s)) {
    cerr << "At pos " << in.tellg() << ", expect ";
    for (const char *p = s; p != s + sz; ++p)
      write_bytes(cerr, *p);
    cerr << ", but get ";
    for (const char *p = buf; p != buf + sz; ++p)
      write_bytes(cerr, *p);
    cerr << endl;
    std::terminate();
  }
}

template <typename Ty, size_t n>
static inline void write_separated(ostream &o, const char *sep,
                                   std::array<Ty, n> list) {
  auto begin = list.begin();
  auto end = list.end();
  if (begin == end)
    return;
  o << setw(sizeof(Ty) * 2) << *begin;
  ++begin;
  for (; begin != end; ++begin)
    o << sep << setw(sizeof(Ty) * 2) << *begin;
}

template <typename Ty> Ty read_integer(istream &in) {
  assert(in);
  constexpr auto size = sizeof(Ty);
  char buf[size];
  in.read(buf, size);
  // May cause error if endian not matched.
  Ty res = *reinterpret_cast<Ty *>(buf);

  // static_assert(std::is_unsigned_v<Ty>);
  // Ty res = 0;
  // for (const char* p = buf; p < buf + size; ++p)  // Big endian
  // for (const char *p = buf + size; p >= buf; --p) // Little endian
  //  (res <<= 8) += static_cast<unsigned char>(*p);
  return res;
}
std::uint32_t read_uint32(istream &in) {
  return read_integer<std::uint32_t>(in);
}
std::int32_t read_int32(istream &in) {
  return static_cast<std::int32_t>(read_integer<std::uint32_t>(in));
}

std::float_t read_float(istream &in) { return read_integer<std::float_t>(in); }

using i64 = std::int64_t;
using u64 = std::uint64_t;
using i32 = std::int32_t;
using u32 = std::uint32_t;
struct patch_info {
  u32 I1;
  u32 I2;
  u32 J1;
  u32 J2;
  u32 K1;
  u32 K2;
  i32 IOR;        // Orientation. 123 stand for XYZ.
  u32 OBST_INDEX; // Obstruction index
  u32 NM;         // Mesh index
  template <typename Callable> void for_each(Callable &&callable) const {
    callable(I1);
    callable(I2);
    callable(J1);
    callable(J2);
    callable(K1);
    callable(K2);
    callable(IOR);
    callable(OBST_INDEX);
    callable(NM);
  }

  const char (&IOR_repr() const noexcept)[3] {
    switch (IOR) {
    case 1:
      return "+X";
    case -1:
      return "-X";
    case 2:
      return "+Y";
    case -2:
      return "-Y";
    case 3:
      return "+Z";
    case -3:
      return "-Z";
    default:
      assert(false);
      return "??";
    }
  }

  u32 I() const noexcept {
    assert(I2 >= I1);
    return I2 - I1 + 1;
  }
  u32 J() const noexcept {
    assert(J2 >= J1);
    return J2 - J1 + 1;
  }
  u32 K() const noexcept {
    assert(K2 >= K1);
    return K2 - K1 + 1;
  }

  u32 size() const noexcept { return I() * J() * K(); }
  friend ostream &operator<<(ostream &o, const patch_info &patch) {
    write_number(o, patch.I1);
    write_number(o, patch.I2);
    write_number(o, patch.J1);
    write_number(o, patch.J2);
    write_number(o, patch.K1);
    write_number(o, patch.K2);
    o << " " << patch.IOR_repr() << " ";
    write_number(o, patch.OBST_INDEX);
    write_number(o, patch.NM);
    write_number(o, patch.size());
    return o;
  }
};
struct patch_data {
  vector<float> data;
};
struct frame {
  float time;
  vector<patch_data> data;
};

/*
 * @retval Label, Bar Label, Units, Patches, Frames
 */
tuple<array<char, 30 + 1>, array<char, 30 + 1>, array<char, 30 + 1>,
      vector<patch_info>, vector<frame>> static inline read_file(istream &fin) {
  array<char, 30 + 1> label, bar_label, units;
  u32 n_patch;

  check(fin, string_separator);
  read(fin, label);
  check(fin, string_separator);
  check(fin, string_separator);
  read(fin, bar_label);
  check(fin, string_separator);
  check(fin, string_separator);
  read(fin, units);
  check(fin, string_separator);

  check(fin, integer_separator);
  n_patch = read_uint32(fin);
  check(fin, integer_separator);

  vector<patch_info> patches;
  for (u32 i = 0; i < n_patch; ++i) {
    check(fin, line_separator);
    u32 I1 = read_uint32(fin);
    u32 I2 = read_uint32(fin);
    u32 J1 = read_uint32(fin);
    u32 J2 = read_uint32(fin);
    u32 K1 = read_uint32(fin);
    u32 K2 = read_uint32(fin);
    i32 IOR = read_int32(fin);
    u32 OBST_INDEX = read_uint32(fin);
    u32 NM = read_uint32(fin);
    patches.push_back({I1, I2, J1, J2, K1, K2, IOR, OBST_INDEX, NM});
    const auto &patch = patches.back();
    check(fin, line_separator);
  }

  vector<frame> vals;
  while (fin.peek() != decay_t<decltype(fin)>::traits_type::eof() &&
         !fin.eof()) {
    vector<patch_data> current(patches.size(), patch_data{});
    check(fin, integer_separator);
    float stime = read_float(fin);
    check(fin, integer_separator);

    for (size_t ip = 0; ip < patches.size(); ++ip) {
      u32 patch_size = read_uint32(fin);
      const auto &info = patches[ip];
      auto _size = info.size();
      assert(_size * sizeof(float) == patch_size);
      for (size_t i = 0; i < info.size(); ++i) {
        float val = read_float(fin);
        current[ip].data.push_back(val);
      }
      u32 patch_end = read_uint32(fin);
      assert(patch_end == patch_size);
    }

    vals.push_back(frame{stime, std::move(current)});
  }
  return {label, bar_label, units, patches, vals};
}

static inline void search_frame_by_time(const vector<frame> &frames) {
  while (true) {
    cout << R"(
Choose search mode.
> - Earliest frame later than given time.
< - Latest frame earlier than given time.
+ - Earliest frame not earlier than given time.
- - Latest frame not later than given time.
d - Discard.
)" << endl;
    char op4 = 'd';
    cin >> op4;
    const auto time_search =
        [&frames = frames](bool (*pred)(float, float, float), bool right) {
          float t = NAN;
          cin >> t;
          for (size_t i = 1; i < frames.size(); ++i)
            if (pred(frames[i - 1].time, t, frames[i].time)) {
              cout << "Frame " << i << " at " << frames[right ? i : i - 1].time
                   << "s." << endl;
              return;
            }
          cout << "Not found." << endl;
        };
    switch (op4) {
    case '>': {
      time_search(
          [](float prev, float t, float cur) { return prev <= t && t < cur; },
          true);
    } break;
    case '+': {
      time_search(
          [](float prev, float t, float cur) { return prev < t && t <= cur; },
          true);
    } break;
    case '<': {
      time_search(
          [](float cur, float t, float next) { return cur <= t && t < next; },
          false);
    } break;
    case '-': {
      time_search(
          [](float cur, float t, float next) { return cur < t && t <= next; },
          false);
    } break;
    case 'd':
      return;
    default:
      break;
    }
  }
}

static inline void search_frame(const vector<frame> &frames) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
t - Time.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << frames.size()
           << " frames in total." << endl;
      u32 f = 0;
      cin >> f;
      if (f >= frames.size()) {
        cout << "Not a valid frame." << endl;
        break;
      }
      cout << "Frame " << f << " is at " << frames[f].time << "s." << endl;
    } break;
    case 't': {
      search_frame_by_time(frames);
    } break;
    case 'd':
      return;
    default:
      break;
    }
  }
}

static inline void search_patch(const vector<patch_info> &patches) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << patches.size()
           << " patches in total." << endl;
      u32 p = 0;
      cin >> p;
      if (p >= patches.size()) {
        cout << "Not a valid patch." << endl;
        break;
      }
      cout << "Patch " << p << ": " << patches[p] << endl;
    } break;
    case 'd':
      return;
    default:
      break;
    }
  }
}

static inline void search_frame_or_patch(const vector<frame> &frames) {
  while (true) {
    cout << R"(
Select item to search for.
f - Frame.
p - Patch.
d - Discard.
)" << endl;
    char op2 = 'd';
    cin >> op2;
    switch (op2) {
    case 'f': {
      search_frame(frames);
    } break;
    case 'p': {
    } break;
    case 'd':
      return;
    default:
      break;
    }
  }
}

/*
 * @retval File stream that reads the corresponding file.
 */
optional<ifstream> select_file() {
  while (true) {
    auto cp = filesystem::current_path();
    auto di = filesystem::directory_iterator(cp);

    cout << R"(
Choose what to do next.
d - Show all sub-directories in current directory.
r - Select a file to read.
c - Change current working directory.
w - Show current working directory.
q - quit
)";
    char opt = 'q';
    cin >> opt;
    switch (opt) {
    case 'd': {
      size_t i = 0;
      for (const auto &entry : di)
        if (entry.is_directory()) {
          cout << i << " - " << entry.path().generic_string() << endl;
          ++i;
        }
    } break;
    case 'r': {
      vector<filesystem::path> files;
      for (const auto &entry : di) {
        const auto &path = entry.path();
        if (path.extension() == ".bf") {
          files.push_back(path);
        }
      }
      cout << "There are " << files.size()
           << " .bf files in total in current directory." << endl;
      if (files.empty()) {
        cout << ".bf files not found in current directory." << endl;
        continue;
      }
      size_t i = 0;
      for (const auto &file : files) {
        cout << i << " - " << file.string() << endl;
        ++i;
      }
      cout << "File index: ";
      cin >> i;
      if (i >= files.size()) {
        cout << "Not a valid file index." << endl;
        continue;
      }
      auto fin = ifstream(files[i], ios::binary);
      if (fin.is_open())
        return fin;
      cout << "Failed to open." << endl;
      continue;
    } break;
    case 'c': {
      cout << "Directory: ";
      string s;
      cin >> s;
      filesystem::path p = s;
      if (filesystem::is_directory(p))
        filesystem::current_path(p);
      else
        cout << "Not a directory." << endl;
    } break;
    case 'w': {
      cout << filesystem::current_path() << endl;
    } break;
    case 'q': {
      return {};
    }
    default:
      break;
    }
  }
}

void show_patch(const vector<patch_info> &patches,
                const vector<frame> &frames) {
  u32 f = 0, p = 0;
  cout << "Select a frame and patch." << endl;
  cout << "Frame index: ";
  cin >> f;
  cout << "Patch index: ";
  cin >> p;
  u32 m = 0, n = 0;
  if (f >= frames.size()) {
    cout << "Not a valid frame." << endl;
    return;
  }
  if (p >= frames[f].data.size()) {
    cout << "Not a valid patch." << endl;
    return;
  }
  const auto &patch = frames[f].data[p];
  switch (patches[p].IOR) {
  case 1:
  case -1:
    m = patches[p].J();
    n = patches[p].K();
    break;
  case 2:
  case -2:
    m = patches[p].I();
    n = patches[p].K();
    break;
  case 3:
  case -3:
    m = patches[p].I();
    n = patches[p].J();
    break;
  default:
    assert(false);
  }

  u32 precision = 0;
  cout << "Precision:";
  cin >> precision;
  cout << setprecision(precision);

  u32 i = 0;
  for (auto v : patch.data) {
    cout << v;
    ++i;
    if (i % m == 0) {
      cout << endl;
    } else
      cout << ' ';
  }
  cout << endl;
}

/// @retval Whether to quit.
bool process_file(array<char, 30 + 1> &label, array<char, 30 + 1> &bar_label,
                  array<char, 30 + 1> &units, const vector<patch_info> &patches,
                  const vector<frame> &frames) {
  constexpr auto help = R"(
Input to get information.
q - Quit.
h - Show this help information.
b - Show boundary quantity information.
f - Show frames information.
p - Show patches information.
o - Show patch data.
s - Search for frame or patch.
u - Unload file.
)";
  cout << help << endl;
  while (true) {
    cout << "Please input your command." << endl;
    char op1 = 'q';
    cin >> op1;
    switch (op1) {
    case 'q':
      return true;
      break;
    case 'u':
      return false;
    case 'b':
      write_line(cout << "Label:     ", label);
      write_line(cout << "Bar Label: ", bar_label);
      write_line(cout << "Units:     ", units);
      break;
    case 'o': {
      show_patch(patches, frames);
    } break;
    case 'f': {
      size_t i = 0;
      for (const auto &f : frames) {
        cout << "Frame " << i << " at " << f.time << "s." << endl;
        ++i;
      }
    } break;
    case 'p': {
      constexpr auto int_len = numeric_limits<i32>::digits10 + 1;
      constexpr auto uint_len = numeric_limits<u32>::digits10 + 1;
      cout << setw(uint_len) << "I1"
           << " " << setw(uint_len) << "I2"
           << " " << setw(uint_len) << "J1"
           << " " << setw(uint_len) << "J2"
           << " " << setw(uint_len) << "K1"
           << " " << setw(uint_len) << "K2"
           << " " << setw(3) << "IOR"
           << " " << setw(uint_len) << "OBST_INDEX"
           << " " << setw(uint_len) << "MESH_INDEX"
           << " " << setw(uint_len) << "SIZE"
           << " " << endl;
      for (const auto &patch : patches)
        cout << patch << endl;
    } break;
    case 's': {
      search_frame_or_patch(frames);
    } break;
    default:
      cout << "Command not found." << endl;
    case 'h':
      cout << help << endl;
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  try {
    while (true) {
      cerr << hex;

      auto in = select_file();
      if (!in.has_value())
        return 1;
      auto &fin = in.value();
      fin.peek();
      if (!fin) {
        cout << "Failed to open the file." << endl;
      }

      cout << "Reading started." << endl;

      auto [label, bar_label, units, patches, frames] = read_file(fin);

      cout << "Reading finished." << endl;

      bool quitting = process_file(label, bar_label, units, patches, frames);
      if (quitting)
        return 0;
    }
  } catch (const exception &e) {
    cerr << e.what() << endl;
    return -1;
  }

  return 0;
}