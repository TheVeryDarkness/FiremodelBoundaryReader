/// @file main.cpp
/// @author Boyi Huang
/// @mainpage Written by Boyi Huang, who was a student in Tongji University when
/// he wrote this. C++17 is required for filesystem operation. GLAD and GLFW3 is
/// required for boundary patch display. For reading .bf files generated by fds.
/// See Source/dump.f90 in fds reposity for more information, especailly codes
/// that are writing data to LU_BNDF(NF,NM). See also section Boundary Files in
/// FDS_User_Guide.pdf. As for opengl, most of the codes about opengl are
/// adapted from https://github.com/JoeyDeVries/LearnOpenGL.
#include "analysis.hpp"
#include "graphics.hpp"
#include "io.hpp"
#include "types.hpp"
#include <array>
#include <cassert>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <optional>
#include <sstream>
#include <string>
#include <valarray>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::getline;
using std::hex;
using std::ifstream;
using std::ios;
using std::optional;
using std::setprecision;
using std::string;
using std::filesystem::current_path;
using std::filesystem::directory_entry;
using std::filesystem::directory_iterator;
using std::filesystem::path;

static inline void search_frame_by_time(const vector<frame> &frames) {
  using std::cin;
  using std::cout;
  constexpr auto help = R"(
Choose search mode.
> - Earliest frame later than given time.
< - Latest frame earlier than given time.
+ - Earliest frame not earlier than given time.
- - Latest frame not later than given time.
d - Discard.
)";
  while (true) {
    cout << help;

    char op4 = 'd';
    cin >> op4;
    const auto time_search =
        [&frames = frames](bool (*pred)(float, float, float), bool right) {
          float t = NAN;
          cin >> t;
          for (size_t i = 1; i < frames.size(); ++i)
            if (pred(frames[i - 1].time, t, frames[i].time)) {
              cout << "Frame " << i << " at " << frames[right ? i : i - 1].time
                   << "s." << endl;
              return;
            }
          cout << "Not found." << endl;
        };
    switch (op4) {
    case '>': {
      time_search(
          [](float prev, float t, float cur) { return prev <= t && t < cur; },
          true);
    } break;
    case '+': {
      time_search(
          [](float prev, float t, float cur) { return prev < t && t <= cur; },
          true);
    } break;
    case '<': {
      time_search(
          [](float cur, float t, float next) { return cur <= t && t < next; },
          false);
    } break;
    case '-': {
      time_search(
          [](float cur, float t, float next) { return cur < t && t <= next; },
          false);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_frame(const vector<frame> &frames) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
t - Time.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << frames.size()
           << " frames in total." << endl;
      u32 f = 0;
      cin >> f;
      if (f >= frames.size()) {
        cout << "Not a valid frame." << endl;
        break;
      }
      cout << "Frame " << f << " is at " << frames[f].time << "s." << endl;
    } break;
    case 't': {
      search_frame_by_time(frames);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_patch(const vector<patch_info> &patches) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << patches.size()
           << " patches in total." << endl;
      u32 p = 0;
      cin >> p;
      if (p >= patches.size()) {
        cout << "Not a valid patch." << endl;
        break;
      }
      cout << "Patch " << p << ": " << patches[p] << endl;
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_frame_or_patch(const vector<frame> &frames,
                                         const vector<patch_info> &patches) {
  while (true) {
    cout << R"(
Select item to search for.
f - Frame.
p - Patch.
d - Discard.
)" << endl;
    char op2 = 'd';
    cin >> op2;
    switch (op2) {
    case 'f': {
      search_frame(frames);
    } break;
    case 'p': {
      search_patch(patches);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

/*
 * @retval File stream that reads the corresponding file.
 */
static inline optional<ifstream> select_file() {
  constexpr auto help = R"(
Choose what to do next.
h - Show this list.
d - Show all sub-directories in current directory and change current working directory.
r - Select a file to read.
c - Change current working directory.
p - Change current directory to parent directory if there is one.
q - quit
)";
  cout << help;
  while (true) {
    auto cp = current_path();
    auto di = directory_iterator(cp);

    cout << endl << cp.string() << "> ";
    char opt = 'q';
    cin >> opt;
    switch (opt) {
    case 'd': {
      size_t i = 0;
      vector<directory_entry> entries;
      for (const auto &entry : di)
        if (entry.is_directory()) {
          cout << i << " - " << entry.path().generic_string() << endl;
          entries.push_back(entry);
          ++i;
        }
      if (entries.empty()) {
        cout << "No sub-directory found." << endl;
        break;
      }
      cout << "Directory index(Invalid index to discard): ";
      cin >> i;
      if (i < entries.size())
        current_path(entries[i]);
    } break;
    case 'r': {
      vector<path> files;
      for (const auto &entry : di) {
        const auto &path = entry.path();
        if (path.extension() == ".bf") {
          files.push_back(path);
        }
      }
      cout << "There are " << files.size()
           << " .bf files in total in current directory." << endl;
      if (files.empty()) {
        cout << ".bf files not found in current directory." << endl;
        continue;
      }
      size_t i = 0;
      for (const auto &file : files) {
        cout << i << " - " << file.string() << endl;
        ++i;
      }
      cout << "File index: ";
      cin >> i;
      if (i >= files.size()) {
        cout << "Not a valid file index." << endl;
        continue;
      }
      auto fin = ifstream(files[i], ios::binary);
      if (fin.is_open())
        return fin;
      cout << "Failed to open." << endl;
      continue;
    } break;
    case 'c': {
      cout << "Directory: ";
      string s;
      getline(cin, s);
      if (s.empty())
        getline(cin, s);
      path p = s;
      if (is_directory(p))
        current_path(p);
      else
        cout << "Not a directory." << endl;
    } break;
    case 'p': {
      current_path(current_path().parent_path());
    } break;
    case 'q': {
      return {};
    }
    default:
      cout << "Command not found." << endl;
    case 'h': {
      cout << help;
    } break;
    }
  }
}

static inline void analyze_patch(const vector<patch_info> &patches,
                                 const vector<frame> &frames, u32 i_patch) {
  const auto &patch = patches[i_patch];
  vector<float> data;
  vector<u32> sizes;
  while (true) {
    cout << R"(
Commands:
m - Show current dimensions.
p - Print current result to console.
w - Input in console to overlap current result.
f - Flatten current result to specified dimension.
s - Take patch data in a frame as current result.
a - Calculate average on specified dimension of current result.
d - Discard.
)";
    char opt = 'd';
    cin >> opt;
    switch (opt) {
    case 'd':
      return;
    case 'w': {
      cout << "Input 0 to stop." << endl << "Expected size: ";
      u32 sz = 0;
      sizes.clear();
      do {
        sz = 0;
        cin >> sz;
        if (sz == 0)
          break;
        sizes.push_back(sz);
      } while (true);

      u32 data_size = array_stride(sizes, 0);

      float e = 0.f;
      data.clear();
      data.reserve(data_size);
      while (data.size() < data_size) {
        cin >> e;
        data.push_back(e);
      }
    } break;
    case 'm': {
      if (sizes.empty())
        break;
      auto begin = sizes.cbegin(), end = sizes.cend();
      cout << *begin;
      ++begin;
      for (; begin != end; ++begin)
        cout << '*' << *begin;
    } break;
    case 'p':
      if (sizes.size() > 2) {
        cout << "Data dimension " << sizes.size() << " > 2." << endl;
      } else if (sizes.size() == 0) {
        if (data.size() == 1)
          cout << endl << data[0] << endl;
        else
          cout << "Data not found." << endl;
      } else if (sizes.size() == 2) {
        auto m = sizes[0], n = sizes[1];
        print_patch(data, m, n);
      } else {
        auto m = (u32)1, n = sizes[0];
        print_patch(data, m, n);
      }
      break;
    case 'l':
      reduce_dimension(sizes, 1);
      if (sizes.size() > 1)
        cout << "Linearization failed. Current dimension is " << sizes.size()
             << "." << endl;
      break;
    case 's': {
      cout << "Frame index: ";
      auto f = frames.size();
      cin >> f;
      if (f >= frames.size()) {
        cout << "Frame index invalid." << endl;
        break;
      }
      data = frames[f].data[i_patch].data;
      sizes = {patch.I(), patch.J(), patch.K()};
    } break;
    case 'f': {
      size_t d = 2;
      cin >> d;
      reduce_dimension(sizes, d);
      if (sizes.size() > d)
        cout << "Flattening failed. Current dimension is " << sizes.size()
             << "." << endl;
    } break;
    case 'a': {
      // Consider [l][m][n]
      size_t dimension = -1;
      cin >> dimension;
      if (dimension >= sizes.size() || sizes.size() == 1) {
        cout << "Dimension invalid." << endl;
        break;
      }
      data = average(data, sizes, dimension);
      sizes.erase(sizes.cbegin() + dimension);

    } break;
    default:
      break;
    }
  }
}

static inline void select_patch(const vector<patch_info> &patches,
                                const vector<frame> &frames) {
  u32 p = 0;
  cout << "Select a patch to analyze. Input an invalid index to discard."
       << endl;
#if GRAPHICS_ENABLED
  if (current < patches.size())
    cout << "Current patch selected in graphics mode is: " << current << "."
         << endl;
#endif // GRAPHICS_ENABLED

  cout << "Patch index: ";
  cin >> p;
  if (p >= patches.size()) {
    return;
  }

  analyze_patch(patches, frames, p);
}

/// @retval Whether to quit.
/// @param label Boundary quantity label.
/// @param bar_label Boundary quantity label shown on the bar.
/// @param units Display units.
/// @param patches Information of patches stored in the .bf file.
/// @param frames Information and boundary quantity data of frames stored in the
/// .bf file.
static inline bool process_file(array<char, 30 + 1> &label,
                                array<char, 30 + 1> &bar_label,
                                array<char, 30 + 1> &units,
                                const vector<patch_info> &patches,
                                const vector<frame> &frames) {
  constexpr auto help =
      R"(
Commands: 
q - Quit.
h - Show this help.
b - Show boundary quantity information.
f - Show frames.
p - Show patches.
a - Analyze patch data.)"
#if GRAPHICS_ENABLED
      R"(
g - Visualize patches.)"
#endif // GRAPHICS_ENABLED
      R"(
s - Search for frame or patch.
u - Unload file.
)";
  cout << help << endl;
  while (true) {
    cout << "Please input your command here: ";
    char op1 = 'q';
    cin >> op1;
    switch (op1) {
    case 'q':
      return true;
      break;
    case 'u':
      return false;
    case 'b':
      write_line(cout << "Label:     ", label);
      write_line(cout << "Bar Label: ", bar_label);
      write_line(cout << "Units:     ", units);
      break;
    case 'a': {
      select_patch(patches, frames);
    } break;
    case 'f': {
      size_t i = 0;
      for (const auto &f : frames) {
        cout << "Frame " << i << " at " << f.time << "s." << endl;
        ++i;
      }
    } break;
#if GRAPHICS_ENABLED
    case 'g':
      visualize_patch(patches);
      break;
#endif // GRAPHICS_ENABLED
    case 'p': {
      constexpr auto int_len = numeric_limits<i32>::digits10 + 1;
      constexpr auto uint_len = numeric_limits<u32>::digits10 + 1;
      cout << setw(uint_len) << "I1"
           << " " << setw(uint_len) << "I2"
           << " " << setw(uint_len) << "J1"
           << " " << setw(uint_len) << "J2"
           << " " << setw(uint_len) << "K1"
           << " " << setw(uint_len) << "K2"
           << " " << setw(3) << "IOR"
           << " " << setw(uint_len) << "OBST_INDEX"
           << " " << setw(uint_len) << "MESH_INDEX"
           << " " << setw(uint_len) << "SIZE"
           << " " << endl;
      for (const auto &patch : patches)
        cout << patch << endl;
    } break;
    case 's': {
      search_frame_or_patch(frames, patches);
    } break;
    default:
      cout << "Command not found." << endl;
    case 'h':
      cout << help << endl;
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  while (true) {
    try {
      cerr << hex;

      auto in = select_file();
      if (!in.has_value())
        return 1;
      auto &fin = in.value();
      fin.peek();
      if (!fin) {
        cout << "Failed to open the file." << endl;
      }

      cout << "Reading started." << endl;

      auto [label, bar_label, units, patches, frames] = read_file(fin);

      cout << "Reading finished." << endl;

      bool quitting = process_file(label, bar_label, units, patches, frames);
      if (quitting)
        return 0;

    } catch (const exception &e) {
      cerr << "Exception caught: " << e.what() << endl;
    }
  }

  return 0;
}