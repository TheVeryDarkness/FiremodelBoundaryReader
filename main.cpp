// Written by Boyi Huang,
// who was a student in Tongji University when he wrote this.
// For reading .bf files generated by fds.
// See Source/dump.f90 in fds reposity for more information,
// especailly codes that are writing data to LU_BNDF(NF,NM).
// See also section Boundary Files in FDS_User_Guide.pdf.
#include <array>
#include <cassert>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;
template <size_t sz> static inline void read(istream &in, char (&s)[sz]) {
  assert(in);
  static_assert(sz > 0);
  in.get(s, sz);
}

// Actually I'm not sure about their meanings.
constexpr const char string_separator[] = "\x1E\x00\x00\x00";
constexpr const char integer_separator[] = "\x04\x00\x00\x00";
constexpr const char line_separator[] = "\x24\x00\x00\x00";

template <size_t sz>
static inline void write_line(ostream &out, char (&s)[sz]) {
  out.write(s, sz) << endl;
}

template <typename Ty>
static inline ostream &write_number(ostream &out, const Ty &val,
                                    const char *sep = " ") {
  return out << setw(numeric_limits<Ty>::digits10 + 1) << val << sep;
}

static inline ostream &write_bytes(ostream &out, char c,
                                   const char *sep = " ") {
  return out << setw(sizeof(c)) << (unsigned)(unsigned char)(c) << sep;
}

template <size_t sz>
static inline void check(istream &in, const char (&s)[sz]) {
  assert(in);
  static_assert(sz > 0);
  char buf[sz];
  buf[sz - 1] = 0;
  in.read(buf, sz - 1);
  if (strcmp(buf, s)) {
    cerr << "At pos " << in.tellg() << ", expect ";
    for (const char *p = s; p != s + sz; ++p)
      write_bytes(cerr, *p);
    cerr << ", but get ";
    for (const char *p = buf; p != buf + sz; ++p)
      write_bytes(cerr, *p);
    cerr << endl;
    std::terminate();
  }
}

template <typename Ty, size_t n>
static inline void write_separated(ostream &o, const char *sep,
                                   std::array<Ty, n> list) {
  auto begin = list.begin();
  auto end = list.end();
  if (begin == end)
    return;
  o << setw(sizeof(Ty) * 2) << *begin;
  ++begin;
  for (; begin != end; ++begin)
    o << sep << setw(sizeof(Ty) * 2) << *begin;
}

template <typename Ty> Ty read_integer(istream &in) {
  assert(in);
  constexpr auto size = sizeof(Ty);
  char buf[size];
  in.read(buf, size);
  // May cause error if endian not matched.
  Ty res = *reinterpret_cast<Ty *>(buf);

  // static_assert(std::is_unsigned_v<Ty>);
  // Ty res = 0;
  // for (const char* p = buf; p < buf + size; ++p)  // Big endian
  // for (const char *p = buf + size; p >= buf; --p) // Little endian
  //  (res <<= 8) += static_cast<unsigned char>(*p);
  return res;
}
std::uint32_t read_uint32(istream &in) {
  return read_integer<std::uint32_t>(in);
}
std::int32_t read_int32(istream &in) {
  return static_cast<std::int32_t>(read_integer<std::uint32_t>(in));
}

std::float_t read_float(istream &in) { return read_integer<std::float_t>(in); }

using i64 = std::int64_t;
using u64 = std::uint64_t;
using i32 = std::int32_t;
using u32 = std::uint32_t;
struct patch_info {
  u32 I1;
  u32 I2;
  u32 J1;
  u32 J2;
  u32 K1;
  u32 K2;
  i32 IOR;        // Orientation. 123 stand for XYZ.
  u32 OBST_INDEX; // Obstruction index
  u32 NM;         // Mesh index
  template <typename Callable> void for_each(Callable &&callable) const {
    callable(I1);
    callable(I2);
    callable(J1);
    callable(J2);
    callable(K1);
    callable(K2);
    callable(IOR);
    callable(OBST_INDEX);
    callable(NM);
  }

  u32 I() const noexcept {
    assert(I2 >= I1);
    return I2 - I1 + 1;
  }
  u32 J() const noexcept {
    assert(J2 >= J1);
    return J2 - J1 + 1;
  }
  u32 K() const noexcept {
    assert(K2 >= K1);
    return K2 - K1 + 1;
  }

  u32 size() const noexcept { return I() * J() * K(); }
};
struct patch_data {
  vector<float> data;
};
struct frame {
  float time;
  vector<patch_data> data;
};

int main() {
  try {
    ifstream fin("test/4_2_1_1.bf", std::ios::binary);
    cerr << hex;
    if (!fin)
      return -1;

    cout << "Reading started." << endl;

    char label[30 + 1], bar_label[30 + 1], units[30 + 1];
    u32 n_patch;

    check(fin, string_separator);
    read(fin, label);
    check(fin, string_separator);
    check(fin, string_separator);
    read(fin, bar_label);
    check(fin, string_separator);
    check(fin, string_separator);
    read(fin, units);
    check(fin, string_separator);

    check(fin, integer_separator);
    n_patch = read_uint32(fin);
    check(fin, integer_separator);

    vector<patch_info> patches;
    for (u32 i = 0; i < n_patch; ++i) {
      check(fin, line_separator);
      u32 I1 = read_uint32(fin);
      u32 I2 = read_uint32(fin);
      u32 J1 = read_uint32(fin);
      u32 J2 = read_uint32(fin);
      u32 K1 = read_uint32(fin);
      u32 K2 = read_uint32(fin);
      i32 IOR = read_int32(fin);
      u32 OBST_INDEX = read_uint32(fin);
      u32 NM = read_uint32(fin);
      patches.push_back({I1, I2, J1, J2, K1, K2, IOR, OBST_INDEX, NM});
      const auto &patch = patches.back();
      check(fin, line_separator);
    }

    vector<frame> vals;
    while (!fin.eof()) {
      vector<patch_data> current(patches.size(), patch_data{});
      check(fin, integer_separator);
      float stime = read_float(fin);
      check(fin, integer_separator);

      for (size_t ip = 0; ip < patches.size(); ++ip) {
        u32 patch_size = read_uint32(fin);
        const auto &info = patches[ip];
        auto _size = info.size();
        assert(_size * sizeof(float) == patch_size);
        for (size_t i = 0; i < info.size(); ++i) {
          float val = read_float(fin);
          current[ip].data.push_back(val);
        }
        u32 patch_end = read_uint32(fin);
        assert(patch_end == patch_size);
      }

      vals.push_back(frame{stime, std::move(current)});
      fin.peek();
    }

    cout << "Reading finished." << endl;
    constexpr auto help = R"(
Input to get information.
q - Quit.
h - Show this help information.
b - Show boundary quantity information.
f - Show frames information.
p - Show patches information.
)";
    cout << help << endl;
    bool quitting = false;
    while (!quitting) {
      cout << "Please input your command." << endl;
      char c = 'q';
      cin >> c;
      switch (c) {
      case 'q':
        quitting = true;
        break;
      case 'b':
        write_line(cout << "Label:     ", label);
        write_line(cout << "Bar Label: ", bar_label);
        write_line(cout << "Units:     ", units);
        break;
      case 'o': {
        u32 f = 0, p = 0;
        cout << "Select a frame and patch to show." << endl;
        cout << "Frame index:";
        cin >> f;
        cout << "Patch index:";
        cin >> p;
        u32 m = 0, n = 0;
        const auto &patch = vals[f].data[p];
        switch (patches[p].IOR) {
        case 1:
        case -1:
          m = patches[p].J();
          n = patches[p].K();
          break;
        case 2:
        case -2:
          m = patches[p].I();
          n = patches[p].K();
          break;
        case 3:
        case -3:
          m = patches[p].I();
          n = patches[p].J();
          break;
        default:
          assert(false);
        }

        u32 i = 0;
        for (auto v : patch.data) {
          cout << v << ", ";
          ++i;
          if (i == m) {
            cout << endl;
            i = 0;
          }
        }
        cout << endl;
      } break;
      case 'f': {
        size_t i = 0;
        for (const auto &f : vals) {
          cout << "Frame " << i << " at " << f.time << "s" << endl;
          ++i;
        }
      } break;
      case 'p': {
        constexpr auto int_len = numeric_limits<i32>::digits10 + 1;
        constexpr auto uint_len = numeric_limits<u32>::digits10 + 1;
        cout << setw(uint_len) << "I1"
             << " " << setw(uint_len) << "I2"
             << " " << setw(uint_len) << "J1"
             << " " << setw(uint_len) << "J2"
             << " " << setw(uint_len) << "K1"
             << " " << setw(uint_len) << "K2"
             << " " << setw(int_len) << "IOR"
             << " " << setw(uint_len) << "OBST_INDEX"
             << " " << setw(uint_len) << "MESH_INDEX"
             << " " << setw(uint_len) << "SIZE"
             << " " << endl;
        for (const auto &patch : patches) {
          write_number(cout, patch.I1);
          patch.for_each([](const auto &val) { write_number(cout, val); });
          write_number(cout, patch.size()) << endl;
        }
      } break;
      case 'h':
      default:
        cout << help << endl;
        break;
      }
    }

  } catch (const exception &e) {
    cerr << e.what() << endl;
    return -1;
  }

  return 0;
}