/// @file main.cpp
/// @author Boyi Huang
/// @mainpage Written by Boyi Huang, who was a student in Tongji University when
/// he wrote this. C++17 is required for filesystem operation. GLAD and GLFW3 is
/// required for boundary patch display. For reading .bf files generated by fds.
/// See Source/dump.f90 in fds reposity for more information, especailly codes
/// that are writing data to LU_BNDF(NF,NM). See also section Boundary Files in
/// FDS_User_Guide.pdf. As for opengl, most of the codes about opengl are
/// adapted from https://github.com/JoeyDeVries/LearnOpenGL.
#include <array>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <optional>
#include <string>
#include <vector>

#if !defined(GRAPHICS_ENABLED)
#define GRAPHICS_ENABLED 1
#endif // !defined(GRAPHICS_ENABLED)

#if GRAPHICS_ENABLED
#include <glad/glad.h>
#include <glfw/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#endif // GRAPHICS_ENABLED

using namespace std;

class file_error : exception {
public:
  const char *what() const noexcept {
    return "File is not correct. Maybe something unexpected happened when "
           "running fds.";
  }
};
class stream_error : exception {
public:
  const char *what() const noexcept {
    return "File stream terminated unexpectedly. This is usually because of an "
           "unexpected EOF.";
  }
};

#define CHECK_STREAM(STREAM)                                                   \
  if (!(STREAM))                                                               \
    throw stream_error();

#define CHECK_FORMAT(EXPR)                                                     \
  if (!(EXPR))                                                                 \
    throw file_error();

template <size_t sz> static inline void read(istream &in, array<char, sz> &s) {
  CHECK_STREAM(in);
  static_assert(sz > 0);
  in.get(s.data(), sz);
}

// Actually I'm not sure about their meanings.
constexpr static inline const char string_separator[] = "\x1E\x00\x00\x00";
constexpr static inline const char integer_separator[] = "\x04\x00\x00\x00";
constexpr static inline const char line_separator[] = "\x24\x00\x00\x00";

template <size_t sz>
static inline void write_line(ostream &out, array<char, sz> &s) {
  out.write(s.data(), sz) << endl;
}

template <typename Ty>
static inline ostream &write_number(ostream &out, const Ty &val,
                                    const char *sep = " ") {
  return out << setw(numeric_limits<Ty>::digits10 + 1) << val << sep;
}

static inline ostream &write_bytes(ostream &out, char c,
                                   const char *sep = " ") {
  return out << setw(sizeof(c)) << (unsigned)(unsigned char)(c) << sep;
}

template <size_t sz>
static inline void check(istream &in, const char (&s)[sz]) {
  CHECK_STREAM(in);
  static_assert(sz > 0);
  char buf[sz];
  buf[sz - 1] = 0;
  in.read(buf, sz - 1);
  if (strcmp(buf, s)) {
    cerr << "At pos " << in.tellg() << ", expect ";
    for (const char *p = s; p != s + sz; ++p)
      write_bytes(cerr, *p);
    cerr << ", but get ";
    for (const char *p = buf; p != buf + sz; ++p)
      write_bytes(cerr, *p);
    cerr << endl;
    std::terminate();
  }
}

template <typename Ty, size_t n>
static inline void write_separated(ostream &o, const char *sep,
                                   std::array<Ty, n> list) {
  auto begin = list.begin();
  auto end = list.end();
  if (begin == end)
    return;
  o << setw(sizeof(Ty) * 2) << *begin;
  ++begin;
  for (; begin != end; ++begin)
    o << sep << setw(sizeof(Ty) * 2) << *begin;
}

template <typename Ty> static inline Ty read_integer(istream &in) {
  CHECK_STREAM(in);
  constexpr auto size = sizeof(Ty);
  char buf[size];
  in.read(buf, size);
  // May cause error if endian not matched.
  Ty res = *reinterpret_cast<Ty *>(buf);

  // static_assert(std::is_unsigned_v<Ty>);
  // Ty res = 0;
  // for (const char* p = buf; p < buf + size; ++p)  // Big endian
  // for (const char *p = buf + size; p >= buf; --p) // Little endian
  //  (res <<= 8) += static_cast<unsigned char>(*p);
  return res;
}
static inline std::uint32_t read_uint32(istream &in) {
  return read_integer<std::uint32_t>(in);
}
static inline std::int32_t read_int32(istream &in) {
  return static_cast<std::int32_t>(read_integer<std::uint32_t>(in));
}

std::float_t read_float(istream &in) { return read_integer<std::float_t>(in); }

using i64 = std::int64_t;
using u64 = std::uint64_t;
using i32 = std::int32_t;
using u32 = std::uint32_t;
struct patch_info {
  const u32 I1;
  const u32 I2;
  const u32 J1;
  const u32 J2;
  const u32 K1;
  const u32 K2;
  const i32 IOR;        // Orientation. 123 stand for XYZ.
  const u32 OBST_INDEX; // Obstruction index
  const u32 NM;         // Mesh index
  patch_info(u32 I1, u32 I2, u32 J1, u32 J2, u32 K1, u32 K2, i32 IOR,
             u32 OBST_INDEX, u32 NM)
      : I1(I1), I2(I2), J1(J1), J2(J2), K1(K1), K2(K2), IOR(IOR),
        OBST_INDEX(OBST_INDEX), NM(NM) {
    CHECK_FORMAT(I2 >= I1);
    CHECK_FORMAT(J2 >= J1);
    CHECK_FORMAT(K2 >= K1);
    CHECK_FORMAT(IOR != 0);
    CHECK_FORMAT(IOR <= 3);
    CHECK_FORMAT(IOR >= -3);
  }
  patch_info(const patch_info &) noexcept = default;
  template <typename Callable> void for_each(Callable &&callable) const {
    callable(I1);
    callable(I2);
    callable(J1);
    callable(J2);
    callable(K1);
    callable(K2);
    callable(IOR);
    callable(OBST_INDEX);
    callable(NM);
  }

  const char (&IOR_repr() const noexcept)[3] {
    switch (IOR) {
    case 1:
      return "+X";
    case -1:
      return "-X";
    case 2:
      return "+Y";
    case -2:
      return "-Y";
    case 3:
      return "+Z";
    case -3:
      return "-Z";
    default:
      return "??";
    }
  }

  u32 I() const noexcept { return I2 - I1 + 1; }
  u32 J() const noexcept { return J2 - J1 + 1; }
  u32 K() const noexcept { return K2 - K1 + 1; }

  u32 size() const noexcept { return I() * J() * K(); }
  friend ostream &operator<<(ostream &o, const patch_info &patch) {
    write_number(o, patch.I1);
    write_number(o, patch.I2);
    write_number(o, patch.J1);
    write_number(o, patch.J2);
    write_number(o, patch.K1);
    write_number(o, patch.K2);
    o << " " << patch.IOR_repr() << " ";
    write_number(o, patch.OBST_INDEX);
    write_number(o, patch.NM);
    write_number(o, patch.size());
    return o;
  }
};
struct patch_data {
  vector<float> data;
};
struct frame {
  float time;
  vector<patch_data> data;
};

/*
 * @retval Label, Bar Label, Units, Patches, Frames
 */
static inline tuple<array<char, 30 + 1>, array<char, 30 + 1>,
                    array<char, 30 + 1>, vector<patch_info>, vector<frame>>
read_file(istream &fin) {
  tuple<array<char, 30 + 1>, array<char, 30 + 1>, array<char, 30 + 1>,
        vector<patch_info>, vector<frame>>
      res;
  auto &[label, bar_label, units, patches, frames] = res;

  u32 n_patch;

  check(fin, string_separator);
  read(fin, label);
  check(fin, string_separator);
  check(fin, string_separator);
  read(fin, bar_label);
  check(fin, string_separator);
  check(fin, string_separator);
  read(fin, units);
  check(fin, string_separator);

  check(fin, integer_separator);
  n_patch = read_uint32(fin);
  check(fin, integer_separator);

  for (u32 i = 0; i < n_patch; ++i) {
    check(fin, line_separator);
    u32 I1 = read_uint32(fin);
    u32 I2 = read_uint32(fin);
    u32 J1 = read_uint32(fin);
    u32 J2 = read_uint32(fin);
    u32 K1 = read_uint32(fin);
    u32 K2 = read_uint32(fin);
    i32 IOR = read_int32(fin);
    u32 OBST_INDEX = read_uint32(fin);
    u32 NM = read_uint32(fin);
    patches.push_back({I1, I2, J1, J2, K1, K2, IOR, OBST_INDEX, NM});
    const auto &patch = patches.back();
    check(fin, line_separator);
  }

  while (fin.peek() != decay_t<decltype(fin)>::traits_type::eof() &&
         !fin.eof()) {
    vector<patch_data> current(patches.size(), patch_data{});
    check(fin, integer_separator);
    float stime = read_float(fin);
    check(fin, integer_separator);

    for (size_t ip = 0; ip < patches.size(); ++ip) {
      u32 patch_size = read_uint32(fin);
      const auto &info = patches[ip];
      auto _size = info.size();
      CHECK_FORMAT(_size * sizeof(float) == patch_size);
      auto &data = current[ip].data;
      data.reserve(_size);
      for (size_t i = 0; i < info.size(); ++i) {
        float val = read_float(fin);
        data.push_back(val);
      }
      u32 patch_end = read_uint32(fin);
      CHECK_FORMAT(patch_end == patch_size);
    }

    frames.push_back(frame{stime, std::move(current)});
  }
  return res;
}

static inline void search_frame_by_time(const vector<frame> &frames) {
  constexpr auto help = R"(
Choose search mode.
> - Earliest frame later than given time.
< - Latest frame earlier than given time.
+ - Earliest frame not earlier than given time.
- - Latest frame not later than given time.
d - Discard.
)";
  while (true) {
    cout << help;

    char op4 = 'd';
    cin >> op4;
    const auto time_search =
        [&frames = frames](bool (*pred)(float, float, float), bool right) {
          float t = NAN;
          cin >> t;
          for (size_t i = 1; i < frames.size(); ++i)
            if (pred(frames[i - 1].time, t, frames[i].time)) {
              cout << "Frame " << i << " at " << frames[right ? i : i - 1].time
                   << "s." << endl;
              return;
            }
          cout << "Not found." << endl;
        };
    switch (op4) {
    case '>': {
      time_search(
          [](float prev, float t, float cur) { return prev <= t && t < cur; },
          true);
    } break;
    case '+': {
      time_search(
          [](float prev, float t, float cur) { return prev < t && t <= cur; },
          true);
    } break;
    case '<': {
      time_search(
          [](float cur, float t, float next) { return cur <= t && t < next; },
          false);
    } break;
    case '-': {
      time_search(
          [](float cur, float t, float next) { return cur < t && t <= next; },
          false);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_frame(const vector<frame> &frames) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
t - Time.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << frames.size()
           << " frames in total." << endl;
      u32 f = 0;
      cin >> f;
      if (f >= frames.size()) {
        cout << "Not a valid frame." << endl;
        break;
      }
      cout << "Frame " << f << " is at " << frames[f].time << "s." << endl;
    } break;
    case 't': {
      search_frame_by_time(frames);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_patch(const vector<patch_info> &patches) {
  while (true) {
    cout << R"(
Select item to search by.
i - Index.
d - discard.
)";
    char op3 = 'd';
    cin >> op3;
    switch (op3) {
    case 'i': {
      cout << "Input the index. There are " << patches.size()
           << " patches in total." << endl;
      u32 p = 0;
      cin >> p;
      if (p >= patches.size()) {
        cout << "Not a valid patch." << endl;
        break;
      }
      cout << "Patch " << p << ": " << patches[p] << endl;
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

static inline void search_frame_or_patch(const vector<frame> &frames,
                                         const vector<patch_info> &patches) {
  while (true) {
    cout << R"(
Select item to search for.
f - Frame.
p - Patch.
d - Discard.
)" << endl;
    char op2 = 'd';
    cin >> op2;
    switch (op2) {
    case 'f': {
      search_frame(frames);
    } break;
    case 'p': {
      search_patch(patches);
    } break;
    case 'd':
      return;
    default:
      cout << "Option not found." << endl;
      break;
    }
  }
}

/*
 * @retval File stream that reads the corresponding file.
 */
static inline optional<ifstream> select_file() {
  constexpr auto help = R"(
Choose what to do next.
h - Show this list.
d - Show all sub-directories in current directory and change current working directory.
r - Select a file to read.
c - Change current working directory.
p - Change current directory to parent directory if there is one.
q - quit
)";
  cout << help;
  while (true) {
    auto cp = filesystem::current_path();
    auto di = filesystem::directory_iterator(cp);

    cout << endl << cp.string() << "> ";
    char opt = 'q';
    cin >> opt;
    switch (opt) {
    case 'd': {
      size_t i = 0;
      vector<filesystem::directory_entry> entries;
      for (const auto &entry : di)
        if (entry.is_directory()) {
          cout << i << " - " << entry.path().generic_string() << endl;
          entries.push_back(entry);
          ++i;
        }
      if (entries.empty()) {
        cout << "No sub-directory found." << endl;
        break;
      }
      cout << "Directory index(Invalid index to discard): ";
      cin >> i;
      if (i < entries.size())
        filesystem::current_path(entries[i]);
    } break;
    case 'r': {
      vector<filesystem::path> files;
      for (const auto &entry : di) {
        const auto &path = entry.path();
        if (path.extension() == ".bf") {
          files.push_back(path);
        }
      }
      cout << "There are " << files.size()
           << " .bf files in total in current directory." << endl;
      if (files.empty()) {
        cout << ".bf files not found in current directory." << endl;
        continue;
      }
      size_t i = 0;
      for (const auto &file : files) {
        cout << i << " - " << file.string() << endl;
        ++i;
      }
      cout << "File index: ";
      cin >> i;
      if (i >= files.size()) {
        cout << "Not a valid file index." << endl;
        continue;
      }
      auto fin = ifstream(files[i], ios::binary);
      if (fin.is_open())
        return fin;
      cout << "Failed to open." << endl;
      continue;
    } break;
    case 'c': {
      cout << "Directory: ";
      string s;
      getline(cin, s);
      filesystem::path p = s;
      if (filesystem::is_directory(p))
        filesystem::current_path(p);
      else
        cout << "Not a directory." << endl;
    } break;
    case 'p': {
      filesystem::current_path(filesystem::current_path().parent_path());
    } break;
    case 'q': {
      return {};
    }
    default:
      cout << "Command not found." << endl;
    case 'h': {
      cout << help;
    } break;
    }
  }
}

#if GRAPHICS_ENABLED

static inline glm::vec3 cameraPos = glm::vec3(-1.0f, 0.0f, 0.0f);
static inline glm::vec3 cameraFront = glm::vec3(1.0f, 0.0f, 0.0f);
static inline glm::vec3 cameraUp = glm::vec3(0.0f, 0.0f, 1.0f);
/// @var time between current frame and last frame
static inline float deltaTime = 0.0f;
static inline float lastFrame = 0.0f;

#define STR(NUM) #NUM
#define DETECT_ERROR                                                           \
  do {                                                                         \
    auto gl_err = glGetError();                                                \
    if (gl_err != GL_NO_ERROR)                                                 \
      clog << "OpenGL Error " << gl_err << " detected at " __FILE__ "("        \
           << __LINE__ << ")" << endl;                                         \
                                                                               \
    const char *error = nullptr;                                               \
    auto glfw_err = glfwGetError(&error);                                      \
    if (glfw_err != GLFW_NO_ERROR)                                             \
      clog << "GLFW Error " << glfw_err                                        \
           << " detected at " __FILE__ "(" STR(__LINE__) ")" << endl;          \
    if (error && *error)                                                       \
      clog << *error << endl;                                                  \
  } while (0);

static inline bool cursor_enabled = false;
static inline bool patch_loop = false;
static inline size_t current = 0;
static inline vector<GLuint> highlighted;

static inline void highlight(size_t i) {
  if (4 * i < highlighted.size()) {
    highlighted[4 * i + 0] |= 0b10;
    highlighted[4 * i + 1] |= 0b10;
    highlighted[4 * i + 2] |= 0b10;
    highlighted[4 * i + 3] |= 0b10;
  }
}
static inline void unhighlight(size_t i) {
  if (4 * i < highlighted.size()) {
    highlighted[4 * i + 0] &= ~(GLuint)0b10;
    highlighted[4 * i + 1] &= ~(GLuint)0b10;
    highlighted[4 * i + 2] &= ~(GLuint)0b10;
    highlighted[4 * i + 3] &= ~(GLuint)0b10;
  }
}

static inline void onKey(GLFWwindow *window, int key, int scancode, int action,
                         int mods) {
  if (key == GLFW_KEY_ESCAPE)
    if (action == GLFW_PRESS)
      glfwSetWindowShouldClose(window, true);

  if (key == GLFW_KEY_TAB)
    if (action == GLFW_PRESS) {
      cursor_enabled = !cursor_enabled;
      glfwSetInputMode(window, GLFW_CURSOR,
                       cursor_enabled ? GLFW_CURSOR_NORMAL
                                      : GLFW_CURSOR_DISABLED);
    }

  const bool continuous = mods & GLFW_MOD_CAPS_LOCK;

  if (key == GLFW_KEY_LEFT)
    if (action == GLFW_PRESS || (continuous && action == GLFW_REPEAT)) {
      unhighlight(current);
      if (current > 0)
        --current;
      else if (patch_loop)
        current = highlighted.size() / 4;
      highlight(current);
    }

  if (key == GLFW_KEY_RIGHT)
    if (action == GLFW_PRESS || (continuous && action == GLFW_REPEAT)) {
      unhighlight(current);
      if (current * 4 < highlighted.size()) {
        ++current;
      } else if (patch_loop)
        current = 0;
      highlight(current);
    }
}

static inline void onFramebufferSizeChange(GLFWwindow *window, int width,
                                           int height) {
  glViewport(0, 0, width, height);
}

static inline GLfloat sensitivity = 0.01f;
static inline void onMouseMove(GLFWwindow *window, double xposIn,
                               double yposIn) {

  float xpos = static_cast<float>(xposIn);
  float ypos = static_cast<float>(yposIn);
  static bool firstMouse = true;
  static GLfloat lastX;
  static GLfloat lastY;

  if (firstMouse) {
    lastX = xpos;
    lastY = ypos;
    firstMouse = false;
  }

  float xoffset = xpos - lastX;
  /// reversed since y-coordinates go from bottom to top
  float yoffset = lastY - ypos;
  lastX = xpos;
  lastY = ypos;

  if (cursor_enabled)
    return;

  xoffset *= sensitivity;
  yoffset *= sensitivity;

  cameraFront += glm::cross(cameraFront, cameraUp) * xoffset;
  cameraFront /= glm::length(cameraFront);

  auto up = cameraUp;
  cameraUp -= cameraFront * yoffset;
  cameraFront += up * yoffset;

  cameraUp /= glm::length(cameraUp);
  cameraFront /= glm::length(cameraFront);
}

static inline GLfloat rate = 1;
static inline void onScroll(GLFWwindow *window, double xoffset,
                            double yoffset) {
  if (cursor_enabled) {
    rate *= (GLfloat)exp2(yoffset);
  } else {
    GLfloat dx = (GLfloat)xoffset * rate;
    GLfloat dy = (GLfloat)yoffset * rate;
    cameraPos += cameraFront * dy;
  }
}

constexpr static inline auto vertexShaderSource =
    R"(
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in uint aHighlight;

uniform mat4 projection;
uniform mat4 view;

out vec4 color;

void main() {
 gl_Position = projection * view * vec4(aPos.x, aPos.y, aPos.z, 1.0);
 if (aHighlight >= 2) {
  color = vec4(.8f, .1f, .0f, .8f);
 } else if (aHighlight == 1) {
  color = vec4(.1f, .8f, .0f, .8f);
 } else {
  color = vec4(.8f, .8f, .8f, .2f);
 }
}
)";
constexpr static inline auto fragmentShaderSource = R"(
#version 330 core

in vec4 color;

void main() {
 gl_FragColor = color;
}
)";

static inline int visualize_patch(const vector<patch_info> &patches) {
  static bool wireframe = false;
  static GLuint windowWidth = 800;
  static GLuint windowHeight = 600;

  highlighted.resize(patches.size() * 4, 0);
  if (current > patches.size()) {
    current = 0;
  }
  highlight(current);

  while (true) {

    bool start = false;
    while (!start) {
      cout << "Settings:" << endl
           << "f - Display as wireframe: " << wireframe << endl
           << "W - Window width:         " << windowWidth << endl
           << "H - Window height:        " << windowHeight << endl
           << "c - Current patch:        " << current << endl
           << "m - Mouse move sensity:   " << rate << endl
           << "s - Scroll sensity:       " << sensitivity << endl
           << "Options:" << endl
           << "h - Show graphics help." << endl
           << "g - Start patch visualiztion." << endl
           << "d - Discard." << endl;
      char opt = 'd';
      cin >> opt;
      switch (opt) {
      case 'f': {
        cout << "Display as wireframe: ";
        cin >> wireframe;
      } break;
      case 'W': {
        cout << "Window width: ";
        cin >> windowWidth;
      } break;
      case 'H': {
        cout << "Window height: ";
        cin >> windowHeight;
      } break;
      case 'c': {
        cout << "Current patch: ";
        cin >> current;
      } break;
      case 's': {
        cout << "Scroll sensity: ";
        cin >> rate;
      } break;
      case 'm': {
        cout << "Mouse move sensity: ";
        cin >> sensitivity;
      } break;
      case 'h': {
        cout << R"(
Press TAB to enable or disable cursor.
Press CAPS to enable or disable continuous key input.
Press LEFT or RIGHT to change current highlighted patch.
Press ESC to terminate.
Move mouse to rotate the camera when cursor is disabled.
Scroll to move forward or backward when cursor is disabled.
Scroll to modify the scroll sensity when cursor is enabled.
)";
      } break;
      case 'g': {
        start = true;
      } break;
      case 'd':
        return 0;
      default:
        cout << "Option not found." << endl;
        break;
      }
    }

    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

#ifndef NDEBUG
    glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);
#endif // !NDEBUG

    GLFWwindow *window = glfwCreateWindow(windowWidth, windowHeight,
                                          "BoundaryReader", NULL, NULL);
    if (window == NULL) {
      cout << "Failed to create GLFW window." << endl;
      glfwTerminate();
      return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetInputMode(window, GLFW_LOCK_KEY_MODS, GLFW_TRUE);
    glfwSetKeyCallback(window, onKey);
    glfwSetFramebufferSizeCallback(window, onFramebufferSizeChange);
    glfwSetCursorPosCallback(window, onMouseMove);
    glfwSetScrollCallback(window, onScroll);

    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
      cout << "Failed to initialize GLAD" << endl;
      return -1;
    }

#ifndef NDEBUG
    int flags;
    glGetIntegerv(GL_CONTEXT_FLAGS, &flags);
    if (flags & GL_CONTEXT_FLAG_DEBUG_BIT) {
      glEnable(GL_DEBUG_OUTPUT);
      glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
      glDebugMessageCallback(
          [](GLenum source, GLenum type, unsigned int id, GLenum severity,
             GLsizei length, const char *message, const void *userParam) {
            clog << "Debug message (" << id << "): " << message << endl;

            switch (source) {
            case GL_DEBUG_SOURCE_API:
              clog << "Source: API";
              break;
            case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
              clog << "Source: Window System";
              break;
            case GL_DEBUG_SOURCE_SHADER_COMPILER:
              clog << "Source: Shader Compiler";
              break;
            case GL_DEBUG_SOURCE_THIRD_PARTY:
              clog << "Source: Third Party";
              break;
            case GL_DEBUG_SOURCE_APPLICATION:
              clog << "Source: Application";
              break;
            case GL_DEBUG_SOURCE_OTHER:
              clog << "Source: Other";
              break;
            }
            std::cout << std::endl;

            switch (type) {
            case GL_DEBUG_TYPE_ERROR:
              clog << "Type: Error";
              break;
            case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
              clog << "Type: Deprecated Behaviour";
              break;
            case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
              clog << "Type: Undefined Behaviour";
              break;
            case GL_DEBUG_TYPE_PORTABILITY:
              clog << "Type: Portability";
              break;
            case GL_DEBUG_TYPE_PERFORMANCE:
              clog << "Type: Performance";
              break;
            case GL_DEBUG_TYPE_MARKER:
              clog << "Type: Marker";
              break;
            case GL_DEBUG_TYPE_PUSH_GROUP:
              clog << "Type: Push Group";
              break;
            case GL_DEBUG_TYPE_POP_GROUP:
              clog << "Type: Pop Group";
              break;
            case GL_DEBUG_TYPE_OTHER:
              clog << "Type: Other";
              break;
            }
            clog << endl;

            switch (severity) {
            case GL_DEBUG_SEVERITY_HIGH:
              clog << "Severity: high";
              break;
            case GL_DEBUG_SEVERITY_MEDIUM:
              clog << "Severity: medium";
              break;
            case GL_DEBUG_SEVERITY_LOW:
              clog << "Severity: low";
              break;
            case GL_DEBUG_SEVERITY_NOTIFICATION:
              clog << "Severity: notification";
              break;
            }
            clog << endl << endl;
          },
          nullptr);
      glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0,
                            nullptr, GL_TRUE);
    }
#endif // !NDEBUG

    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    DETECT_ERROR;

    int success;
    char infoLog[512];

    auto vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);

    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if (!success) {
      glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
      cerr << infoLog << endl;
    }

    auto fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);

    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if (!success) {
      glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
      cerr << infoLog << endl;
    }

    DETECT_ERROR;

    // link shaders
    auto shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    // check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if (!success) {
      glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
      cerr << infoLog << endl;
    }
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    DETECT_ERROR;

    vector<GLuint> vertices = {};
    vector<GLuint> indices = {};
    for (const auto &patch : patches) {
      const GLuint N = (GLuint)vertices.size() / 3;
      if (wireframe) {
        switch (patch.IOR) {
        case 1:
        case -1:
          indices.push_back(N + 0);
          indices.push_back(N + 1);
          indices.push_back(N + 1);
          indices.push_back(N + 3);
          indices.push_back(N + 3);
          indices.push_back(N + 2);
          indices.push_back(N + 2);
          indices.push_back(N + 0);
          break;
        case 2:
        case -2:
          indices.push_back(N + 0);
          indices.push_back(N + 2);
          indices.push_back(N + 2);
          indices.push_back(N + 1);
          indices.push_back(N + 1);
          indices.push_back(N + 3);
          indices.push_back(N + 3);
          indices.push_back(N + 0);
          break;
        case 3:
        case -3:
          indices.push_back(N + 0);
          indices.push_back(N + 1);
          indices.push_back(N + 1);
          indices.push_back(N + 2);
          indices.push_back(N + 2);
          indices.push_back(N + 3);
          indices.push_back(N + 3);
          indices.push_back(N + 0);
          break;
        default:
          break;
        }
      } else {
        indices.push_back(N + 0);
        indices.push_back(N + 1);
        indices.push_back(N + 2);
        switch (patch.IOR) {
        case 1:
        case -1:
          indices.push_back(N + 1);
          indices.push_back(N + 2);
          indices.push_back(N + 3);
          break;
        case 2:
        case -2:
          indices.push_back(N + 0);
          indices.push_back(N + 1);
          indices.push_back(N + 3);
          break;
        case 3:
        case -3:
          indices.push_back(N + 0);
          indices.push_back(N + 2);
          indices.push_back(N + 3);
          break;
        default:
          break;
        }
      }

      vertices.push_back(patch.I1);
      vertices.push_back(patch.J1);
      vertices.push_back(patch.K1);

      vertices.push_back(patch.I2);
      vertices.push_back(patch.J1);
      vertices.push_back(patch.K2);

      vertices.push_back(patch.I2);
      vertices.push_back(patch.J2);
      vertices.push_back(patch.K1);

      vertices.push_back(patch.I1);
      vertices.push_back(patch.J2);
      vertices.push_back(patch.K2);
    }

    size_t i = 0;
    for (const auto &patch : patches) {
      vertices.push_back(0);
      vertices.push_back(0);
      vertices.push_back(0);
      vertices.push_back(0);
    }

    GLuint VBO[2], VAO, EBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(2, VBO);
    glGenBuffers(1, &EBO);

    DETECT_ERROR;

    glBindVertexArray(VAO);

    DETECT_ERROR;

    glBindBuffer(GL_ARRAY_BUFFER, VBO[0]);
    glBufferData(GL_ARRAY_BUFFER,
                 vertices.size() * sizeof(decltype(vertices)::value_type),
                 vertices.data(), GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_UNSIGNED_INT, GL_FALSE, 3 * sizeof(GLuint),
                          0);

    DETECT_ERROR;

    glBindBuffer(GL_ARRAY_BUFFER, VBO[1]);
    glBufferData(GL_ARRAY_BUFFER,
                 highlighted.size() * sizeof(decltype(highlighted)::value_type),
                 highlighted.data(), GL_DYNAMIC_DRAW);

    glVertexAttribPointer(1, 1, GL_UNSIGNED_INT, GL_FALSE, 1 * sizeof(GLuint),
                          0);

    DETECT_ERROR;

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                 indices.size() * sizeof(decltype(indices)::value_type),
                 indices.data(), GL_STATIC_DRAW);

    DETECT_ERROR;

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);

    DETECT_ERROR;

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    DETECT_ERROR;

    glUseProgram(shaderProgram);

    DETECT_ERROR;

    constexpr auto u32_max = numeric_limits<u32>::max();
    u32 I1 = u32_max, I2 = 0, J1 = u32_max, J2 = 0, K1 = u32_max, K2 = 0;
    for (const auto &patch : patches) {
      I1 = min(patch.I1, I1);
      I2 = max(patch.I2, I2);
      J1 = min(patch.I1, J1);
      J2 = max(patch.I1, J2);
      K1 = min(patch.I1, K1);
      K2 = max(patch.I1, K2);
    }
    float far = 100.;
    if (patches.size() > 0) {
      u32 I, J, K;
      I = I2 - I1;
      J = J2 - J1;
      K = K2 - K1;
      far = float(sqrt(I * I + J * J + K * K) * 2);
    }

    glm::mat4 projection = glm::perspective(
        glm::radians(60.0f), float(windowWidth) / windowHeight, 0.1f, far);

    glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "projection"), 1,
                       false, glm::value_ptr(projection));

    DETECT_ERROR;

    glBindBuffer(GL_ARRAY_BUFFER, VBO[1]);

    // Render loop
    while (!glfwWindowShouldClose(window)) {
      // camera/view transformation
      glm::mat4 view =
          glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
      glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "view"), 1, false,
                         glm::value_ptr(view));

      DETECT_ERROR;

      glBufferData(GL_ARRAY_BUFFER,
                   highlighted.size() *
                       sizeof(decltype(highlighted)::value_type),
                   highlighted.data(), GL_DYNAMIC_DRAW);

      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

      glUseProgram(shaderProgram);
      glBindVertexArray(VAO);
      if (wireframe)
        glDrawElements(GL_LINES, (GLuint)indices.size(), GL_UNSIGNED_INT, 0);
      else
        glDrawElements(GL_TRIANGLES, (GLuint)indices.size(), GL_UNSIGNED_INT,
                       0);

      glfwSwapBuffers(window);
      // glfwPollEvents();
      glfwWaitEvents();

      DETECT_ERROR;
    }

    glBindBuffer(GL_ARRAY_BUFFER, 0);

    DETECT_ERROR;

    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(2, VBO);
    glDeleteProgram(shaderProgram);

    glfwTerminate();
  }
}
#endif // GRAPHICS_ENABLED

static inline void print_patch(const vector<patch_info> &patches,
                               const vector<frame> &frames, u32 p, u32 m,
                               u32 n) {
  u32 f = 0;
  cin >> f;
  if (f >= frames.size()) {
    cout << "Not a valid frame." << endl;
    return;
  }

  u32 precision = 0;
  cout << "Precision:";
  cin >> precision;
  cout << setprecision(precision);

  const auto &patch = frames[f].data[p];
  u32 i = 0;
  for (auto v : patch.data) {
    cout << v;
    ++i;
    if (i % m == 0) {
      cout << endl;
    } else
      cout << ' ';
  }
  cout << endl;
}

static inline void reduce_dimension(vector<u32> &sizes, size_t target) {
  for (size_t i = 0; i < sizes.size() && sizes.size() > target; ++i) {
    if (sizes[i] == 1) {
      sizes.erase(sizes.cbegin() + i);
      --i;
    }
  }
}

/// @brief Access data in the flattened multi-dimension array.
static inline u32 array_offset(const vector<u32> &sizes,
                               const vector<u32> &index) {
  u32 offset = 0;
  auto s1 = sizes.begin(), s2 = sizes.end();
  auto i1 = index.begin(), i2 = index.end();
  for (; s1 != s2 && i1 != i2; ++s1, ++i1)
    offset *= *s1, offset += *i1;
  return offset;
}

static inline u32 array_stride(const vector<u32> &sizes, size_t d) {
  u32 res = 1;
  auto p = sizes.begin() + d + 1, end = sizes.end();
  for (; p != end; ++p)
    res *= *p;
  return res;
}

/// @brief Increment the index.
static inline bool increment_index(const vector<u32> &sizes,
                                   vector<u32> &index) {
  auto rbegin = index.rbegin(), rend = index.rend();
  auto srbegin = sizes.rbegin(), srend = sizes.rend();
  if (rbegin == rend)
    return true;
  ++*rbegin;

  while (*rbegin == *srbegin) {
    *rbegin = 0;
    ++rbegin;
    if (rbegin == rend)
      return true;
    ++*rbegin;
    ++srbegin;
  }
  return false;
}

static inline void analyze_patch(const vector<patch_info> &patches,
                                 const vector<frame> &frames, u32 p) {
  const auto &patch = patches[p];
  vector<float> data;
  vector<u32> sizes;
  while (true) {
    cout << R"(
Commands:
print     - Print current result to console.
flat      - Flat current result.
linearize - Linearize current result.
drop      - Drop current result.
snapshot  - Take patch data in a frame as current result.
average   - Calculate average on specified dimension of current result.
discard   - Discard.
)";
    string opt;
    cin >> opt;
    if (opt == "print")
      if (sizes.size() > 2) {
        cout << "Data dimension " << sizes.size() << " > 2." << endl;
      } else if (sizes.size() == 0) {
        cout << "Data not found." << endl;
      } else if (sizes.size() == 2) {
        auto m = sizes[0], n = sizes[1];
        print_patch(patches, frames, p, m, n);
      } else {
        auto m = sizes[0], n = (u32)1;
        print_patch(patches, frames, p, m, n);
      }
    else if (opt == "flat") {
      reduce_dimension(sizes, 2);
      if (sizes.size() > 2)
        cout << "Flattening failed. Current dimension is " << sizes.size()
             << "." << endl;
    } else if (opt == "linearize") {
      reduce_dimension(sizes, 1);
      if (sizes.size() > 1)
        cout << "Linearization failed. Current dimension is " << sizes.size()
             << "." << endl;
    } else if (opt == "drop") {
      data.clear();
      sizes.clear();
    } else if (opt == "snapshot") {
      cout << "Frame index: ";
      auto f = frames.size();
      cin >> f;
      if (f >= frames.size()) {
        cout << "Frame index invalid." << endl;
        break;
      }
      data = frames[f].data[p].data;
      sizes = {patch.I(), patch.J(), patch.K()};
    } else if (opt == "average") {
      break;
      size_t dimension = 0;
      cin >> dimension;
      if (dimension >= sizes.size()) {
        cout << "Dimension invalid." << endl;
        break;
      }
      vector<u32> index(sizes.size(), 0);

      auto base = array_offset(sizes, index);
      auto stride = array_stride(sizes, dimension);
      for (size_t i = 0; i < sizes[dimension]; ++i)
        ;
    } else if (opt == "discard") {
      return;
    }
  }
}

static inline void select_patch(const vector<patch_info> &patches,
                                const vector<frame> &frames) {
  u32 p = 0;
  while (true) {
    cout << "Select a patch to analyze. Input an invalid index to discard."
         << endl;
#if GRAPHICS_ENABLED
    if (current < patches.size())
      cout << "Current patch selected in graphics mode is: " << p << "."
           << endl;
#endif // GRAPHICS_ENABLED

    cout << "Patch index: ";
    cin >> p;
    if (p >= patches.size()) {
      return;
    }

    analyze_patch(patches, frames, p);
  }
}

/// @retval Whether to quit.
/// @param label Boundary quantity label.
/// @param bar_label Boundary quantity label shown on the bar.
/// @param units Display units.
/// @param patches Information of patches stored in the .bf file.
/// @param frames Information and boundary quantity data of frames stored in the
/// .bf file.
static inline bool process_file(array<char, 30 + 1> &label,
                                array<char, 30 + 1> &bar_label,
                                array<char, 30 + 1> &units,
                                const vector<patch_info> &patches,
                                const vector<frame> &frames) {
  constexpr auto help =
      R"(
Commands: 
q - Quit.
h - Show this help.
b - Show boundary quantity information.
f - Show frames.
p - Show patches.
a - Analyze patch data.)"
#if GRAPHICS_ENABLED
      R"(
g - Visualize patches.)"
#endif // GRAPHICS_ENABLED
      R"(
s - Search for frame or patch.
u - Unload file.
)";
  cout << help << endl;
  while (true) {
    cout << "Please input your command here: ";
    char op1 = 'q';
    cin >> op1;
    switch (op1) {
    case 'q':
      return true;
      break;
    case 'u':
      return false;
    case 'b':
      write_line(cout << "Label:     ", label);
      write_line(cout << "Bar Label: ", bar_label);
      write_line(cout << "Units:     ", units);
      break;
    case 'a': {
      select_patch(patches, frames);
    } break;
    case 'f': {
      size_t i = 0;
      for (const auto &f : frames) {
        cout << "Frame " << i << " at " << f.time << "s." << endl;
        ++i;
      }
    } break;
#if GRAPHICS_ENABLED
    case 'g':
      visualize_patch(patches);
      break;
#endif // GRAPHICS_ENABLED
    case 'p': {
      constexpr auto int_len = numeric_limits<i32>::digits10 + 1;
      constexpr auto uint_len = numeric_limits<u32>::digits10 + 1;
      cout << setw(uint_len) << "I1"
           << " " << setw(uint_len) << "I2"
           << " " << setw(uint_len) << "J1"
           << " " << setw(uint_len) << "J2"
           << " " << setw(uint_len) << "K1"
           << " " << setw(uint_len) << "K2"
           << " " << setw(3) << "IOR"
           << " " << setw(uint_len) << "OBST_INDEX"
           << " " << setw(uint_len) << "MESH_INDEX"
           << " " << setw(uint_len) << "SIZE"
           << " " << endl;
      for (const auto &patch : patches)
        cout << patch << endl;
    } break;
    case 's': {
      search_frame_or_patch(frames, patches);
    } break;
    default:
      cout << "Command not found." << endl;
    case 'h':
      cout << help << endl;
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  while (true) {
    try {
      cerr << hex;

      auto in = select_file();
      if (!in.has_value())
        return 1;
      auto &fin = in.value();
      fin.peek();
      if (!fin) {
        cout << "Failed to open the file." << endl;
      }

      cout << "Reading started." << endl;

      auto [label, bar_label, units, patches, frames] = read_file(fin);

      cout << "Reading finished." << endl;

      bool quitting = process_file(label, bar_label, units, patches, frames);
      if (quitting)
        return 0;

    } catch (const exception &e) {
      cerr << "Exception caught: " << e.what() << endl;
    }
  }

  return 0;
}